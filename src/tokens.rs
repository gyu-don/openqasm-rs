use keyword;

struct Token {
    pub token: TokenType,
    pub filename: Option<&str>,
    pub position: (usize, usize),
}

enum TokenType {
    Real(f64),
    UInt(usize),
    Idenfier(String),
    StringLiteral(String),
    Comment(String),
    // keywords
    Openqasm,
    Include,
    Qreg,
    Creg,
    Barrier,
    Gate,
    If,
    Measure,
    Opaque,
    Reset,
    // builtin const
    Pi,
    // builtin gates
    U,
    CX,
    // builtin unary op
    Sin,
    Cos,
    Tan,
    Exp,
    Ln,
    Sqrt,
    // Marks
    Plus,
    Minus,
    Times,
    Devide,
    Power,
    Comma,
    Semicolon,
    DoubleEqual,
    Arrow,
    // brackets
    LParen,
    RParen,
    LBrace,
    RBrace,
    LSqBracket,
    RSqBracket,
}

fn match_keyword_exact(s: &str) -> Option<TokenType> {
    Some(match s {
        OPENQASM    => TokenType::Openqasm,
        INCLUDE     => TokenType::Include,
        QREG        => TokenType::Qreg,
        CREG        => TokenType::Creg,
        BARRIER     => TokenType::Barrier,
        GATE        => TokenType::Gate,
        IF          => TokenType::If,
        MEASURE     => TokenType::Measure,
        OPAQUE      => TokenType::Opaque,
        RESET       => TokenType::Reset,
        PI          => TokenType::Pi,
        U           => TokenType::U,
        CX          => TokenType::CX,
        SIN         => TokenType::Sin,
        COS         => TokenType::Cos,
        TAN         => TokenType::Tan,
        EXP         => TokenType::Exp,
        LN          => TokenType::Ln,
        SQRT        => TokenType::Sqrt,
        PLUS        => TokenType::Plus,
        MINUS       => TokenType::Minus,
        TIMES       => TokenType::Times,
        DEVIDE      => TokenType::Devide,
        POWER       => TokenType::Power,
        COMMA       => TokenType::Comma,
        SEMICOLON   => TokenType::Semicolon,
        DOUBLEEQUAL => TokenType::DoubleEqual,
        ARROW       => TokenType::Arrow,
        LPAREN      => TokenType::LParen,
        RPAREN      => TokenType::RParen,
        LBRACE      => TokenType::LBrace,
        RBRACE      => TokenType::RBrace,
        LSQBRACKET  => TokenType::LSqBracket,
        RSQBRACKET  => TokenType::RSqBracket,
        _ => return None,
    })
}
